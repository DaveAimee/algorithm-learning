package chapter2_dsu.excersice;

import java.util.Arrays;
import java.util.Comparator;
import java.util.PriorityQueue;

//leetcode924: https://leetcode-cn.com/problems/minimize-malware-spread/
public class MinimizeMalwareSpread {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        //1.Color each element
        Arrays.sort(initial);
        int len = graph.length;
        int[] colors = new int[len];
        Arrays.fill(colors,-1);
        //2.遍历每个节点，如果没有颜色，遍历其所有连通分量上色
        int currentColor = 0;
        boolean[] visited = new boolean[len];
        int[] colorNums = new int[graph.length];
        for(int i=0;i<len;i++) {
            if(colors[i]==-1) {
               dfs(i,currentColor++,visited,graph,colors,colorNums);
            }
        }
        //3.找到initial中颜色唯一的点 色彩->出现的次数
        int[] colorTimes = new int[graph.length];
        Arrays.fill(colorTimes, 0);
        for(int i=0;i<initial.length;i++) {
            colorTimes[colors[initial[i]]]++;
        }
        //Set<Integer> nodeShowOnce = new HashSet<>();
        Comparator<Integer> comp = new Comparator<Integer> () {
            @Override
            public int compare(Integer x, Integer y) {
                if(colorNums[colors[x]] < colorNums[colors[y]]) {
                    return 1;
                }
                else if(colorNums[colors[x]] == colorNums[colors[y]]){
                    if(x<y) {
                        return -1;
                    }
                    else if(x==y) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                else {
                    return -1;
                }
            }
        };
        PriorityQueue<Integer> nodeShowOnce = new PriorityQueue<Integer>(comp);
        for(int i=0;i<initial.length;i++) {
            if(colorTimes[colors[initial[i]]]==1) {
                nodeShowOnce.add(initial[i]);
            }
        }
        if(nodeShowOnce.isEmpty()) {
            return initial[0];
        }
        return nodeShowOnce.peek();
    }    
    private void dfs(int i,int currentColor,boolean[] visited,int[][] graph,int[] colors,int [] colorNums) {
        if(!visited[i]) {
            visited[i] = true;
            colors[i]=currentColor;
            colorNums[currentColor]++;
            for(int j=0;j<visited.length;j++) {
                if(graph[i][j]==1) {
                    dfs(j,currentColor,visited,graph,colors,colorNums);
                }
            }
        }
    }
}
